"use strict"; class DeepProxy { constructor(e, t = {}) { return this.handler = { set: (t, r, n) => (t && t[r] != n && (t[r] = n instanceof Object ? new Proxy(n, this.handler) : n, e(this.model)), !0) }, this.model = new Proxy(t, this.handler), this.model } } let views = []; const compare = (e, t) => { if (typeof e != typeof t) return !1; if (Object.is(e, t)) return !0; if (0 === Object.keys(e).length && 0 === Object.keys(t).length) return !0; for (let r in e) return e.hasOwnProperty(r) === t.hasOwnProperty(r) && (e[r] instanceof Object && t[r] instanceof Object ? compare(e[r], t[r]) : Object.is(e[r], t[r])) }, program = (e, t = {}, r = document.getElementById("app")) => { const n = e => { if (!e) return; if (0 == e.type.indexOf("_")) switch (e.type) { case "_TEXT": return document.createTextNode(e.prop.content) }const t = document.createElement(e.type); for (let r in e.prop) /^on/.test(r) ? t.addEventListener(r.replace(/^on/, "").toLowerCase(), e.prop[r]) : t.setAttribute(r, e.prop[r]); return e.childs.map(n).forEach(t.appendChild.bind(t)), t }, o = (e, t, r, i = 0) => { if (r) if (t) { if (((e, t) => e.type != t.type || !compare(e.prop, t.prop) || e.childs.length != t.childs.length)(t, r)) e.replaceChild(n(t), e.childNodes[i]); else if (t.type) for (let n = 0; n < t.childs.length || n < r.childs.length; n++)o(e.childNodes[i], t.childs[n], r.childs[n], n) } else e.removeChild(e.childNodes[i]); else e.appendChild(n(t)) }; let i = new DeepProxy(t => { let n = views[views.length - 1], i = e(t); o(r, i, n), views[views.length] = i }, t); return i.initialized = !0, i }, router = e => { Node.prototype.q = function (e) { try { return Array.prototype.slice.call(this.querySelectorAll(e)) } catch (e) { return [] } }; const t = (e, t) => { if (-1 != t.indexOf("?")) { if (e = e.split("/"), t = t.split("/"), e.length != t.length) return !1; let r = {}; for (let n in t) { let o = t[n]; if (0 == o.indexOf("?")) r[o.substr(1)] = e[n]; else if (o != e[n]) return !1 } return r } if (e == t) return {} }; window.onhashchange = (r => { document.q("route").forEach(e => e.style.display = "none"); let n = document.q("route[when]"); for (let r in n) { let o, i = n[r], l = window.location.hash.substr(1), s = i.getAttribute("when"); if (o = t(l, s) || "*" == s) return e.route = o, void (i.style.display = "block") } }), window.onhashchange() }, el = (e, t = {}, r = []) => ({ type: e, prop: t, childs: r }), div = (e, t) => el("div", e, t), span = (e, t) => el("span", e, t), br = (e = {}) => el("br", e), button = (e, t) => el("button", e, t), header = (e, t) => el("header", e, t), footer = (e, t) => el("footer", e, t), article = (e, t) => el("article", e, t), root = (e = []) => div({}, e), route = (e, t) => el("ROUTE", { when: e }, t), text = e => el("_TEXT", { content: e }, []);